let crypto = require( "crypto" ) ;
let fs = require( "fs" ) ;
let path = require( "path" ) ;
var appRoot = require( 'app-root-path' ) ;
let colors = require( "colors" ) ;
let URLPattern = require( "url-pattern" ) ;
let isValidPath = require('is-valid-path') ;

/**
 * üóùÔ∏è Create API & Server keys with Permissions and CustomData üóùÔ∏è
 * @module authkeys
 */

/**
 * Create a new AuthKey instance directly from a method.
 * @param {String} [str] - The value of the key to work like a index value.
 * @returns {AuthKey}
 * @see {@link #authkeys~AuthKey} to see all parameters and execution ways.
 * @example
 * // This will generate a key with a random index value (sha256 hash).
 * const { AuthKey } = require( "@purpleboost/authkeys" ) ;
 * const key = new AuthKey( ) ;
 * @also
 * @param {String} [str] - The secret-string to generate a hash as key-index.
 * @param {String} algorithm - The algorithm used to generate the hash.
 * @example
 * const { AuthKey } = require( "@purpleboost/authkeys" ) ;
 * const key = new AuthKey( "secret", "md5" ) ;
 */
module.exports.createKey = function( str, algorithm ) {
  return new AuthKey( str, algorithm ) ;
} ;

/**
 * Create a new key from a simple object.
 * @param {object} obj - An object obtained with *authKey.toJSON( )* method 
 * @returns {AuthKey}
 */
module.exports.parseKey = function( obj ) {
  return AuthKey.parse( obj ) ;
} ;

/**
 * Load a key from a file saved with *authKey.save( )* method.
 * @param {string} file - The path of the file with all *hex* data.
 * @returns {AuthKey}
 */
module.exports.loadKey = function( file ) {
  return AuthKey.load( file ) ;
}


/**
 * Create key instances with multiple methods to manage them.
 * @class
 */
class AuthKey {
  /**
   * Generate a new AuthKey with a token (hash) generated by a random secret-string.
   *   
   * **Note:** We define *token* as the value of the key used to identify it, like the value you enter in your API url (www.mysite.com/api?token=mytoken). 
   *
   * @param {String} [str] - The custom token of the key or the secret to generate the key-token hash.
   * @param {String} [algorithm] - The algorithm used to generate the hash.
   * @example <caption>Random SHA256-Hash Token (CommonJS)</caption>
   * const { AuthKey } = require( "@purpleboost/authkeys" ) ;
   * const key = new AuthKey( ) ;
   * @example <caption>Random SHA256-Hash Token (ES6)</caption>
   * import { AuthKey } from "@purpleboost/authkeys" ;
   * const key = new AuthKey( ) ;
   * @example <caption>Custom Token</caption>
   * const { AuthKey } = require( "@purpleboost/authkeys" ) ;
   * const key = new AuthKey( "my-key-token" ) ;
   * @example <caption>Custom Hash-Token</caption>
   * const { AuthKey } = require( "@purpleboost/authkeys" ) ;
   * const key = new AuthKey( "my-secret-string", "sha256" ) ;
   * @example <caption>Random Hash-Token with Custom Algorithm</caption>
   * const { AuthKey } = require( "@purpleboost/authkeys" ) ;
   * const key = new AuthKey( null, "md5" ) ;
   */
  constructor( str, algorithm ) {
    defineAuthKeyProperties( this, [ "algorithm", "token", "secret", "permissions", "data" ] ) ;
    // INIT CONSTRUCTION [v] ;
    this.public = getRandomString( 32 ) ;
    this.$data = { } ;
    this.$permissions = { } ;
    this.$algorithm = ( typeof algorithm === "string" ? algorithm : "sha256" ).toLowerCase( ) ;
    if( AuthKey.getAlgorithms( ).indexOf( this.$algorithm ) === -1 ) 
      { throw new Error( `The algorithm "${ this.$algorithm }" is not available in Node.js crypto (AuthKey).`.red ) ; }
    if( typeof str === "undefined" || str === null ) {
      // AUTO-GENERATE SECRET [v] ;
      this.$secret = getRandomString( 64 ) ;
      this.$token = crypto.createHash( this.$algorithm ).update( this.$secret ).digest( "hex" ) ;
    } else if( typeof str === "string" && !algorithm ) {
      // CUSTOM KEY-INDEX [v] ;
      if( str.length <= 0 ) { throw new Error( "AuthKey token<string> is empty.".red ) ; }
      this.$token = str ;
    } else if( typeof str === "string" && typeof algorithm === "string" ) {
      if( str.length <= 4 ) { throw new Error( "AuthKey secret must be at least 4 characters long".red ) ; }
      this.$secret = str ;
      this.$token = crypto.createHash( this.$algorithm ).update( this.$secret ).digest( "hex" ) ;     
    } else {
      throw new Error( "Invalid constructor parameters: AuthKey( str<string>, algorithm<string> )".red ) ;
    }
  }

  /**
   * A random 32-length (default) string to use as a public password for the token.
   * @type {string}
   * @default RANDOM
   * @example <caption>Change Public-Password</caption>
   * key.public = "new-public-value" ;
   */
  public = null ;

  /**
   * Generate a new public alpha-numeric password.
   * @param {number} [length=32] 
   * @returns {string} - The new *public* value.
   */
  refreshPublicPassword( length ) {
    let p = getRandomString( length || 32 ) ;
    this.public = p ;
    return p ;
  }

  /**
   * The string used to generate the key token (hash).
   * Use **updateToken( )** before to use the new secret string.
   * @type {string}
   * @default RANDOM  
   */
  get secret( ) { return this.$secret ; }
  set secret( str ) {
    if( typeof str !== "string" ) { throw new Error( "AuthKey secret must be an string.".red ) ; }
    if( str.length <= 4 ) { throw new Error( "AuthKey secret must be at least 4 characters long".red ) ; }
    this.$secret = str ;
  }

  /**
   * Update the current key token based on the key-secret.
   * @param {string} [algorithm=current] - Select a hash algorithm to generate token string (sha256 by default).
   */
  updateToken( algorithm ) {
    algorithm = typeof algorithm === "string" ? algorithm : ( this.$algorithm || "sha256" ) ;
    if( AuthKey.getAlgorithms( ).indexOf( algorithm ) === -1 ) 
      { throw new Error( `The algorithm "${ algorithm }" is not available in Node.js crypto (AuthKey).`.red ) ; }
    this.$token = crypto.createHash( this.$algorithm ).update( this.$secret ).digest( "hex" ) ;     
    this.$algorithm = algorithm ;
  }

  /**
   * The algorithm used to generate the key token (hash).
   * @type {string}
   * @default sha256
   * @readonly
   */
  get algorithm( ) { return this.$algorithm ; } 

  /**
   * The token of the current key.
   * @type {string}
   * @readonly
   */
  get token( ) { return this.$token } ;

  /**
   * Get all available algorithms to generate hash values for key-index.
   * @returns {string[]}
   */
  static getAlgorithms( ) {
    return crypto.getHashes( ) ;
  }

  // REAL FEATURES [v] ;

  /**
   * Get/Set custom data for the key.
   * @param {string} key
   * @param {string|number|boolean|object|null} [val]
   * @example <caption>Set Data</caption>
   * key.data( "name", "blitzcrank" ) ;
   * @example <caption>Get Data</caption>
   * const name = key.data( "name" ) ;
   */
  data( key, val ) {
    if( typeof key !== "string" ) { throw new Error( "The \"key\" parameter is required (AuthKey).".red ) ; }
    if( typeof val === "undefined" ) {
      return this.$data[ key ] ;
    } else {
      return this.$data[ key ] = val ;
    }
  }

  /**
   * Set or remove permissions from the current key.
   * 
   * **Tip:** You can use url patterns to indicate, for example, that a url must include the name of a user in order to be allowed to write or read (See example).
   * @see {@link http://expressjs.com/en/guide/routing.html} to watch url pattern examples.
   * @param {string} key - The path or key to store the permission.
   * @param {string} [str] - A string with all permissions and the operation (add, remove or check).
   * @example <caption>Modifying Basic Permissions</caption>
   * // Adding permissions (+)
   * // Read, Write, Delete and Execute
   * key.permission( "docs", "+rwdx" ) ;
   * 
   * // Removing permissions (-)
   * key.permission( "docs", "-w" ) ;
   * @example <caption>Creating URL-Path Permissions</caption>
   * // Can read and write in any URL under users/USERNAME/.
   * key.permission( "users/USERNAME/*", "+rw" ) ;
   * @example <caption>Checking Permissions</caption>
   * // To check permissions just define the first letter of the permission type.
   * const canRead = key.permission( "users/blitzcrank/inventory", "r" ) ; // <= read
   * // or
   * const canRead = key.permission( "users/blitzcrank/inventory" ).read ;
   * console.log( canRead ) ; // <= Expected: true (See last example)
   */
  permission( key, val ) {
    if( typeof key !== "string" ) { throw new Error( "No \"key\" parameter defined".red ) ; }
    let types = { r : "read", w : "write", d : "delete", x : "execute" } ;
    let authKey = this ;
    function checkIndex( ) {
      if( typeof authKey.$permissions[ key ] === "object" )
        { return true ; }
      authKey.$permissions[ key ] = { 
        pattern : new URLPattern( key ) , 
        list : { }
      } ;
    } // CHECK P-INDEX [^] ;
    if( typeof val !== "string" ) {
      // RETURN LIST [v] ;
      var obj = this.$permissions[ key ] ;
      if( typeof obj === "object" ) { return obj.list ; }
      let index = null ;
      for( var i in this.$permissions ) {
        if( this.$permissions[ i ].pattern.match( key ) ) 
          { index = i ; break ; }
      } if( !index ) {
        var list = { } ;
        for( var type in types ) {
          list[ types[ type ] ] = false ;
        } return list ;
      } else {
        for( var o in types ) {
          if( typeof authKey.$permissions[ index ].list[ types[ o ] ] === "undefined" ) 
            { authKey.$permissions[ index ].list[ types[ o ] ] = false ; } 
        } // PREPARE [^] ;
        return this.$permissions[ index ].list ;
      }
    } else if( val.indexOf( "+" ) === 0 || val.indexOf( "-" ) === 0 ) {
      checkIndex( ) ;
      const arr = val.split( "" ) ;
      arr.forEach( function( t ) {
        if( !types[ t ] ) { return null ; }
        const granted = val.indexOf( "+" ) === 0 ? true : false ;
        authKey.$permissions[ key ].list[ types[ t ] ] = granted ;
      } ) ;
      return true ;
    } else if( val.length > 0 ) {
      throw new Error( "To check permissions you must set one permission type per request (r,w,d or x )." ) ;
    } else {
      const type = types[ val ] ;
      if( !type ) { throw new Error( `Invalid permission type "${ val }"`.red ) ; }
      var obj = this.$permissions[ key ] ;
      if( typeof obj === "object" ) { return obj.list[ type ] || false ; }
      let index = null ;
      for( var i in this.$permissions ) {
        if( this.$permissions[ i ].pattern.match( key ) ) 
          { index = i ; break ; }
      } if( !index ) {
        return false ;
      } else {
        return this.$permissions[ index ].list[ type ] || false ;
      }
    }
  }

  /**
   * Return all permissions (added=true or not=false) of a given key/path.
   * @param {string} key - The key or url-pattern to check permissions.
   * @returns {object} - All possible permissions (true or false) for the current key.
   * @example
   * key.permission( "users/blitzcrank/*", "+w" ) ;
   * if( key.checkPermissions( "users/blitzcrank/edit" ).write === true ) {
   *   // do something...
   * }
   */
  checkPermissions( key ) {
    return this.permission( key ) ;
  }

  /**
   * Convert the current key data into a simple object to store in cloud services, then you will able to parse it with AuthKey.parse( ) static method.
   * @returns {object}
   */
  toJSON( ) {
    let permissionsList = { } ;
    for( var i in this.$permissions ) {
      const item = this.$permissions[ i ] ;
      permissionsList[ i ] = {
        list : item.list
      } ;
    }
    return {
      secret : this.secret ,
      public : this.public ,
      token  : this.token  ,
      algorithm : this.algorithm ,
      permissions : permissionsList ,
      data : this.$data
    } ;
  }

  /**
   * Save the current key data (hex) into a local-storage file.
   * @param {string} file - The file path to store the key data.
   */
  save( file ) {
    if( !isValidPath( file ) ) { throw new Error( "Invalid file-path at authKey.save( ) call.".red ) ; }
    let json = this.toJSON( ) ;
    let raw = Buffer.from( JSON.stringify( json ), "utf8" ).toString( "hex" ) ;
    fs.writeFileSync( file, raw ) ;
    return true ;
  }

  /**
   * Load AuthKey from a file saved with authKey.save( ) method.
   * @param {string} file - The file path. 
   * @returns {AuthKey}
   */
  static load( file ) {
    if( typeof file !== "string" ) { throw new Error( "No file path defined at AuthKey.load( ) static method".red ) ; }
    if( !fs.existsSync( file ) ) { throw new Error( "File not found: AuthKey.load( \"" + file + "\" )" ) ; }
    var raw = fs.readFileSync( file, "utf-8" ) ;
    raw = Buffer.from( raw, "hex" ).toString( "utf8" ) ;
    let obj = JSON.parse( raw ) ;
    return AuthKey.parse( obj ) ;
  }

  /**
   * Convert a simple object from **toJSON( )** method into an AuthKey instance.
   * @param {object} data
   * @returns {AuthKey}
   */
  static parse( data ) {
    const required = [ "secret", "public", "token", "algorithm" ] ;
    if( typeof data !== "object" ) { throw new Error( "Invalid object defined at AuthKey.parse( ) call.".red ) ; }
    for( var i = 0 ; i < required.length ; i++ ) {
      if( !data[ required[ i ] ] ) { throw new Error( `Required "${ required[ i ] }" property not found in the AuthKey.parse parameter object.` ) ; }
    } // CONTINUE [v] ;
    let key = new AuthKey( ) ;
    key.$secret = data.secret ;
    key.$algorithm = data.algorithm ;
    key.$token = data.token ;
    key.public = data.public ;
    key.$data = data.data || { } ;
    // PROCESS PERMISSIONS [v] ;
    if( typeof data.permissions === "object" ) {
      for( var z in data.permissions ) {
        key.$permissions[ z ] = {
          pattern : new URLPattern( z ) ,
          list : data.permissions[ z ].list
        } ;
      }
    } // RETURN [v] ;
    return key ;
  }

} ;

function defineAuthKeyProperties( o, arr ) {
  if( !( o instanceof AuthKey ) ) { throw new Error( "Invalid AuthKey object.".yellow ) ; }
  function hide( key ) {
    let $ = null ;
    return Object.defineProperty( o, `$${ key }`, { 
      enumerable : false , configurable : false ,
      get( ) { return $ } , set( v ) { $ = v ; }
    } ) ;
  } // HIDE FUNCTION [^] ;
  arr.forEach( p => hide( p ) ) ;
} 

module.exports.AuthKey = AuthKey ;

// TOOLS [v] ;
function getRandomString( length ) {
  var result           = '' ;
  var characters       = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789' ;
  var charactersLength = characters.length ;
  for ( var i = 0; i < length; i++ ) {
    result += characters.charAt( Math.floor( Math.random( ) * charactersLength ) ) ;
  } return result ;
}